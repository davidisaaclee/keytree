match = require 'util/match'
_     = require 'underscore'

# Example grammar
# ---------------
#
# P := (el N NE)
#
# NE := (num N)
#     | (arg N)
#     | (arith A NE NE)
#     | (if BE NE NE)
#
# BE := (bool B)
#     | (rel R NE NE)
#     | (log L BE BE)


# A `Piece` is an element of a `Sequence`.
class Piece
  constructor: ->

# Describes a `Piece` which matches a constant string.
class Literal extends Piece
  constructor: (@text) ->

# Describes a "hole" in a `Pattern`, as well as the
#   valid `Category` which can fill the hole.
class Hole extends Piece
  constructor: (@category, @identifier) ->

# A `Pattern` is used to describe a `Symbol`'s syntax.
class Pattern
  constructor: ->

# Describes a `Piece` using regular expressions.
class Regex extends Pattern
  constructor: (@regex) ->

# Describes a `Pattern` using a sequence of `Piece`s.
class Sequence extends Pattern
  constructor: (@pieces) ->
    @holes = {}
    @pieces.map (elm, index) =>
      if elm.constructor.name is 'Hole'
        @holes[elm.identifier] =
          index: index
          category: elm.category
          value: null

  navigate: (path) ->
    helper = ([hd, tl...], currentHole) ->
      if hd is undefined
        currentHole
      else
        if currentHole.value? and currentHole.value.holes[hd]?
          helper tl, currentHole.value.holes[hd]
        else
          # nothing at that path; return undefined
          undefined

    helper path, @root

  fillHole: (path, withSequence) ->
    hole = @navigate path
    if hole?
      hole.value = withSequence

  # firstHole: () ->
  #   helper = (pcs, index) -> match (_.first pcs),
  #     Literal: (lit) -> helper (_.rest pcs), (index + 1)
  #     Hole: (hole) -> {hole: hole, index: index}

  #   helper @pieces, 0

  # # Replace the hole at index `index` with `Sequence` `withSequence`.
  # replace: (index, withSequence) ->
  #   @pieces.splice index, 1, withSequence.pieces...
  #   @clean()

  # Concatenates multiple adjacent literals; removes empty literals.
  # clean: () ->
  #   concatAdjacents = (pcs) ->
  #     i = 0
  #     while i < (pcs.length - 1)
  #       if (pcs[i].constructor.name is 'Literal') and
  #          (pcs[i + 1].constructor.name is 'Literal')
  #       then pcs.splice i, 2, new Literal (pcs[i].text + pcs[i + 1].text)
  #       else i += 1
  #     return pcs

  # removeEmpties = (pcs) ->
  #   i = 0
  #   while i < (pcs.length - 1)
  #     if (pcs[i].constructor.name is 'Literal') and
  #        (pcs[i].text.length is 0)
  #     then pcs.splice i, 1
  #     else i += 1
  #   return pcs

  # removeEmpties (concatAdjacents @pieces)

# Example syntax - delete me!
# syntax =
#   'NE': [
#     ['(num ', 'N', ')']
#     ['(arg ', 'N', ')']
#     ['(arith ', 'A', 'NE', 'NE', ')']
#   ]
#   'BE': [
#     ['(bool ', 'B', ')']
#     ['(rel ', 'R', 'NE', 'NE', ')']
#     ['(log ', 'L', 'BE', 'BE', ')']
#   ]

class Grammar
  constructor: (categories) ->
    @categories = {}
    mkSymbol = (symbols, category) -> (new Symbol pattern, category) for pattern in symbols
    @categories[category] = (mkSymbol symbols, category) for category, symbols of categories

  matchesCategory: (categoryIdentifier, piece) ->
    category = @categories[categoryIdentifier]
    if not category?
      throw new Error "No such category `#{categoryIdentifier}`."
    else
      # TODO
      true


# Represents a category of symbols.
# In the example grammar, {P, NE, BE} are categories.
class Category
  constructor: (@identifier, @symbols...) ->


# Represents a terminal or non-terminal symbol.
# For the category BE in the example grammar,
#   {(bool B), (rel R NE NE), (log L BE BE)} are symbols.
class Symbol
  constructor: (@pattern, @category) ->


# Represents an AST.
class SyntaxTree
  constructor: (@root) ->
    # TODO


# Represents a node in the AST.
class Node
  constructor: (@symbol) ->
    # TODO: construct way to fill hole

  fillHole: (hole, withNode) ->
    # TODO


class Program
  constructor: (@grammar, outerCategory = 'DEFAULT') ->
    @programSequence = new Sequence [new Hole (outerCategory)]

  nextUnfilledHole: () ->
    i = 0
    while @programSequence.holes[i]? and
          @programSequence.holes[i].value?
      console.log "passing over #{@programSequence.holes[i].category}"
      i++
    @programSequence.holes[i]

  fillHole: (path, piece) ->
    hole = @programSequence.navigate path

    if hole?
      # Check that this is a valid fill.
      if not @grammar.matchesCategory hole.category, piece
        throw new Error "Expected piece of category #{hole.category}; got #{JSON.stringify piece}"

      @programSequence.fillHole path, piece

  symbolsForCategory: (category) -> @grammar.categories[category]



# terser constructors: turn `new Class(args...)` into `Class(args...)`
generateConstructor = (klass) -> (args...) -> new klass args...

module.exports =
  Grammar: Grammar
  Symbol: Symbol
  Category: Category
  Literal: generateConstructor Literal
  Hole: generateConstructor Hole
  Regex: generateConstructor Regex
  Sequence: generateConstructor Sequence
  Program: Program