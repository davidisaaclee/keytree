{"version":3,"sources":["../node_modules/browserify/node_modules/browser-pack/_prelude.js","../node_modules/TreeModel/build/TreeModel.js","../node_modules/TreeModel/node_modules/oo-eventtarget/index.js","../node_modules/TreeModel/node_modules/oo-eventtarget/lib/$EventTarget.js","src/scripts/SyntaxTree.coffee","test/spec/SyntaxTreeSpec.coffee","test/test-bundle.coffee"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1VA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA,IAAA,yEAAA;EAAA;;;AAAA,SAAA,GAAY,OAAA,CAAQ,WAAR;;;AAGZ;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;;;;;;;;;AAQM;;;;AAEJ;;;;;;EAKa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","file":"test-bundle.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Generated by CoffeeScript 1.9.2\n(function() {\n  var EventTargetMixin, TreeModel, extend,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    slice = [].slice;\n\n  EventTargetMixin = require('oo-eventtarget');\n\n  extend = function(obj, fields) {\n    var key, result, value;\n    result = {};\n    for (key in obj) {\n      value = obj[key];\n      result[key] = value;\n    }\n    for (key in fields) {\n      value = fields[key];\n      result[key] = value;\n    }\n    return result;\n  };\n\n\n  /*\n  Represents nested data as an ordered tree structure. Provides support for\n  mutation observation. Can be used in conjunction with `TreeTransformer` to\n  lazily and automatically transform between different tree representations.\n   */\n\n  TreeModel = (function() {\n\n    /*\n    Constructs a `TreeModel` with an optional value to hold.\n    \n    @param [a] value This node's held value.\n     */\n    function TreeModel(value1) {\n      this.value = value1;\n      this._bubble = bind(this._bubble, this);\n      this._mutate((function(_this) {\n        return function() {\n          EventTargetMixin(_this);\n\n          /*\n          @property [Array] Mapping of keys to this node's children, in the form:\n            node: TreeModel\n            key: String\n           */\n          _this._children = {};\n\n          /*\n          @property [Array<String>] An ordered list of keys for this node's children.\n           */\n          _this.orderedChildrenKeys = [];\n\n          /*\n          @property [Array<TreeModel>] An ordered list of this node's children.\n           */\n          return Object.defineProperty(_this, 'childList', {\n            get: function() {\n              return this.orderedChildrenKeys.map((function(_this) {\n                return function(key) {\n                  return _this._children[key].node;\n                };\n              })(this));\n            }\n          });\n        };\n      })(this));\n    }\n\n\n    /*\n    @property [TreeModel] This node's parent node, or `null` if root.\n     */\n\n    TreeModel.prototype.parent = null;\n\n\n    /*\n    @property [String] The key by which this node's parent refers to this node,\n      or `null` if root.\n     */\n\n    TreeModel.prototype.key = null;\n\n\n    /*\n    @param [String] key\n    @return [TreeModel] The specified child node, or `null` if no such child.\n     */\n\n    TreeModel.prototype.getChild = function(key) {\n      if (this._children[key] != null) {\n        return this._children[key].node;\n      } else {\n        return null;\n      }\n    };\n\n\n    /*\n    Returns the index of the specified child, or `null` if no such child.\n    \n    @param [String] key\n    @return [Integer] The index of the child at `key`, or `null` if no such child.\n     */\n\n    TreeModel.prototype.getIndexOfChild = function(key) {\n      if (this._children[key] != null) {\n        return this._children[key].index;\n      } else {\n        return null;\n      }\n    };\n\n\n    /*\n    @param [String] key\n    @param [TreeModel] node\n     */\n\n    TreeModel.prototype.addChild = function(key, node) {\n      return this._mutate((function(_this) {\n        return function() {\n          var index;\n          if (key == null) {\n            return null;\n          }\n          _this.removeChild(key);\n          node.parent = _this;\n          node.key = key;\n          node.addEventListener('changed', _this._bubble(key));\n          _this.orderedChildrenKeys.push(key);\n          index = _this.orderedChildrenKeys.length - 1;\n          _this._children[key] = {\n            node: node,\n            index: index\n          };\n          return _this._children[key].node;\n        };\n      })(this));\n    };\n\n\n    /*\n    If a child exists at the specified key, replaces the child node at `key` with\n      the specified node.\n      If no such child exists, adds the node as a child at the specified key.\n    \n    @param [String] key The child's key.\n    @param [TreeModel] node The node to put in the existing child's place.\n    @return [TreeModel] The \"adopted\" child node (`node`)\n     */\n\n    TreeModel.prototype.setChild = function(key, node) {\n      if (this._children[key] != null) {\n        return this._mutate((function(_this) {\n          return function() {\n            return _this._children[key].node = node;\n          };\n        })(this));\n      } else {\n        return this.addChild(key, node);\n      }\n    };\n\n\n    /*\n    @param [String] key Key of child to be removed.\n    @return [TreeModel] The removed child.\n     */\n\n    TreeModel.prototype.removeChild = function(key) {\n      var toDelete;\n      if (this._children[key] != null) {\n        toDelete = this._children[key];\n        return this._mutate((function(_this) {\n          return function() {\n            return toDelete.node._mutate(function() {\n              var reorderChildren;\n              toDelete.node.removeEventListener('changed', _this._bubble(key));\n              toDelete.node.parent = null;\n              toDelete.node.key = null;\n              _this.orderedChildrenKeys.splice(_this._children[key].index, 1);\n              delete _this._children[key];\n              reorderChildren = function(startIndex) {\n                var i, j, ref, ref1, results;\n                results = [];\n                for (i = j = ref = startIndex, ref1 = _this.orderedChildrenKeys.length; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {\n                  results.push(_this._children[_this.orderedChildrenKeys[i]].index = i);\n                }\n                return results;\n              };\n              reorderChildren(toDelete.index);\n              return toDelete.node;\n            });\n          };\n        })(this));\n      }\n    };\n\n\n    /*\n    Alias for `removeChild`.\n    \n    @param [String] key Key of child to be detached.\n    @return [TreeModel] The detached child.\n     */\n\n    TreeModel.prototype.detach = function() {\n      return this.removeChild.apply(this, arguments);\n    };\n\n\n    /*\n    Creates a new node and places it at the provided path.\n    \n    Note: This is a mutating method, but the mutation is delegated to the\n    new node's parent via `addChild`.\n    \n    @param [Array<String>] path The path where the new node should live.\n    @param [a] value The value to be placed in the new node.\n    @return [TreeModel<a>] The newly-created node, or `null` if invalid path.\n     */\n\n    TreeModel.prototype.put = function(arg, value) {\n      var j, key, parent, parentPath;\n      parentPath = 2 <= arg.length ? slice.call(arg, 0, j = arg.length - 1) : (j = 0, []), key = arg[j++];\n      parent = this.navigate(parentPath);\n      if ((parent != null) && (key != null)) {\n        return parent.addChild(key, new TreeModel(value));\n      } else {\n        if (key == null) {\n          throw new RangeError('Attempted to put value at an undefined key.');\n        } else if (parent == null) {\n          throw new RangeError('Attempted to put value at invalid path.');\n        }\n      }\n    };\n\n\n    /*\n    Navigates to a node and returns that node if it exists.\n    \n    @param [Array<String>] path A path to the node, with the node's key as the last element.\n    @return [TreeModel] The specified node, or `null` if no such node.\n     */\n\n    TreeModel.prototype.navigate = function(path) {\n      var hd, ref, tl;\n      hd = path[0], tl = 2 <= path.length ? slice.call(path, 1) : [];\n      switch (false) {\n        case hd == null:\n          return (ref = this.getChild(hd)) != null ? ref.navigate(tl) : void 0;\n        default:\n          return this;\n      }\n    };\n\n\n    /*\n    Removes all children from this node.\n    \n    @return [TreeModel] This model.\n     */\n\n    TreeModel.prototype.clear = function() {\n      return this._mutate((function(_this) {\n        return function() {\n          _this.orderedChildrenKeys.forEach(function(key) {\n            return _this.removeChild(key);\n          });\n          return _this;\n        };\n      })(this));\n    };\n\n\n    /*\n     */\n\n    TreeModel.prototype.batchMutate = function(proc) {\n      return this._mutate((function(_this) {\n        return function() {\n          return proc(_this);\n        };\n      })(this));\n    };\n\n\n    /*\n    Performs a mutation action, sending off changed events.\n    \n    @param [Function] procedure The action to perform.\n    @return [?] The result of procedure.\n     */\n\n    TreeModel.prototype._mutate = function(procedure) {\n      var r;\n      if (!this._isMutating) {\n        this._isMutating = true;\n        r = procedure();\n        this._fireChanged();\n        this._isMutating = false;\n        return r;\n      } else {\n        return procedure();\n      }\n    };\n\n\n    /*\n    Fires a changed event.\n    \n    @param [TreeModel] node The changed node.\n     */\n\n    TreeModel.prototype._fireChanged = function() {\n      return this.dispatchEvent('changed', {\n        node: this,\n        path: []\n      });\n    };\n\n    TreeModel.prototype._bubble = function(childKey) {\n      return (function(_this) {\n        return function(evt) {\n          var data;\n          if (!_this._isMutating) {\n            data = extend(evt.data, {\n              path: [childKey].concat(slice.call(evt.data.path))\n            });\n            return _this.dispatchEvent(evt.type, data);\n          }\n        };\n      })(this);\n    };\n\n    return TreeModel;\n\n  })();\n\n  module.exports = TreeModel;\n\n}).call(this);\n","module.exports = require(\"./lib/$EventTarget.js\");","/**\r\n\t$EventTarget mixin\r\n\t@author Bart Van Beurden\r\n\t@date 26/01/2014\r\n**/\r\n\r\n/**\r\n\tEvents dispatched by $EventTarget have 3 properties:\r\n\t- type (string)\r\n\t- target (event source)\r\n\t- data (user-provided)\r\n**/\r\nvar Event = function(type, target, data) {\r\n\tthis.type = type;\r\n\tthis.target = target;\r\n\tthis.data = data;\r\n};\r\n\r\n/**\r\n\t$EventTarget mixin\r\n\tExtends an object with EventTarget methods\r\n\t(adds #addEventListener, #removeEventListener, #dispatchEvent)\r\n\t@param obj The object to extend\r\n**/\r\nmodule.exports = function(obj) {\r\n\r\n\tobj._listeners = {};\r\n\tvar proto = Object.getPrototypeOf(obj);\r\n\t\r\n\t// if necessary, extend prototype\r\n\tif (!proto.addEventListener) {\r\n\t\r\n\t\t/**\r\n\t\t\t$EventTarget#addEventListener\r\n\t\t\t@param type The event Type to listen to\r\n\t\t\t@param callback(event) The listener function\r\n\t\t\t@returns this\r\n\t\t**/\r\n\t\tObject.defineProperty(proto, \"addEventListener\", { value: function(type, callback) {\r\n\t\t\tconsole.assert(typeof type == \"string\", \"$EventTarget#addEventListener - type must be string\");\r\n\t\t\tconsole.assert(typeof callback == \"function\", \"$EventTarget#addEventListener - callback must be function\");\r\n\t\t\t\r\n\t\t\tvar listeners = this._listeners[type];\r\n\t\t\tif (!listeners) listeners = this._listeners[type] = [];\r\n\t\t\tlisteners.push(callback);\r\n\t\t\treturn this;\r\n\t\t}});\r\n\t\t\r\n\t\t/**\r\n\t\t\t$EventTarget#removeEventListener\r\n\t\t\t@param type The event Type to remove\r\n\t\t\t@param callback(event) The listener function to remove\r\n\t\t\t@returns this\r\n\t\t**/\r\n\t\tObject.defineProperty(proto, \"removeEventListener\", { value: function(type, callback) {\r\n\t\t\tconsole.assert(typeof type == \"string\", \"$EventTarget#removeEventListener - type must be string\");\r\n\t\t\tconsole.assert(typeof callback == \"function\", \"$EventTarget#removeEventListener - callback must be function\");\r\n\t\t\t\r\n\t\t\tvar listeners = this._listeners[type];\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar index = listeners.indexOf(callback);\r\n\t\t\t\tif (index != -1) {\r\n\t\t\t\t\tlisteners.splice(index, 1);\r\n\t\t\t\t\tif (listeners.length == 0) delete this._listeners[type];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}});\r\n\t\t\r\n\t\tObject.defineProperty(proto, \"clearEventListeners\", { value: function(type) {\r\n\t\t\t\r\n\t\t\tif (arguments.length == 0) {\r\n\t\t\t\tthis._listeners = {};\r\n\t\t\t} else {\r\n\t\t\t\tdelete this._listeners[type];\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}});\r\n\t\t\r\n\t\tvar dispatcher = function(event) { \r\n\t\t\treturn function(callback) { \r\n\t\t\t\tcallback(event);\r\n\t\t\t};\r\n\t\t};\r\n\t\t\r\n\t\t/**\r\n\t\t\t$EventTarget#dispatchEvent\r\n\t\t\t@param type The type of the event to dispatch\r\n\t\t\t@param data [Optional] The data to pass to the listeners\r\n\t\t**/\r\n\t\tObject.defineProperty(proto, \"dispatchEvent\", { value: function(type, data) {\r\n\t\t\tconsole.assert(typeof type == \"string\", \"$EventTarget#dispatchEvent - type must be string\");\r\n\t\t\t\r\n\t\t\t(this._listeners[type] || []).forEach(dispatcher(new Event(type, this, data)));\r\n\t\t}});\r\n\t};\r\n\t\r\n\treturn obj;\r\n\r\n};","TreeModel = require 'TreeModel'\n\n\n###\nTREE STRUCTURE\n\nHoleNode -> ExpressionNode\n\nExpressionNode -> Array<InstanceNode>\n\nInstanceNode -> Array<ExpressionNode>\nInstanceNode -> Array<HoleNode>\nInstanceNode -> Array<InputNode>\nInstanceNode -> Array<LiteralNode>\n\nInputNode -> LiteralNode ? (to hold the user string)\n###\n\n###\nTemplate ::=\n  group: [String]\n  expression: [Subexpression]\n\nPiece ::= [Subexpression]\n        | [Hole]\n        | [Literal]\n        | [Input]\n\nSubexpression ::=\n  type: 'subexpression'\n  quantifier: [String]\n  identifier: [String]\n  pieces: [Array<Piece>]\n\nHole ::=\n  type: 'hole'\n  quantifier: [String]\n  identifier: [String]\n  acceptCondition: [Function<Template, Boolean>]\n\nLiteral ::=\n  type: 'literal'\n  quantifier: [String]\n  text: [String]\n\nInput ::=\n  type: 'input'\n  quantifier: [String]\n  identifier: [String]\n  pattern: [String]\n###\n\n\n###\nAn `ExpressionNode` represents a template of grammatical pieces. This template\n  is instantiated one or more times into `InstanceNode`s.\n  For an `ExpressionNode` to be represented in the output source, it must have at\n  least one `InstanceNode`.\n\nThe `value` field of this node holds this expression's template.\n###\nclass ExpressionNode extends TreeModel\n\n  ###\n  Constructs an `ExpressionNode`, given the expression template.\n\n  @param [Subexpression] expression The expression model.\n  ###\n  constructor: (expression) ->\n    super\n      identifier: expression.identifier\n      template: expression.pieces\n\n    ###\n    @property [Array<InstanceNode>] instances An ordered list of this\n      `ExpressionNode`'s `InstanceNode`s.\n    ###\n    Object.defineProperty this, 'instances',\n      get: () -> @childList\n\n    ###\n    @property [Array<Piece>] template The template which all instances of this\n      node should follow.\n    ###\n    Object.defineProperty this, 'template',\n      get: () -> @value.template\n\n    instanceCounter = 0\n    @_instanceIndex = () -> instanceCounter++\n\n  ###\n  Creates and adds an empty instance to the end of this node's list of\n    instances.\n  @return [InstanceNode] The newly created node.\n  ###\n  instantiate: () ->\n    key = '#' + @_instanceIndex()\n    @addChild key, new InstanceNode @template\n\n\n###\nAn `InstanceNode` is an instantiation of an `ExpressionNode`, which offers a\n  buffer in which to fill the `ExpressionNode`'s template.\nThe `value` field of this node holds a reference to the parent\n  `ExpressionNode`'s template.\n###\nclass InstanceNode extends TreeModel\n  ###\n  @param [Array<Piece>] template\n  ###\n  constructor: (template) ->\n    super template: template\n\n    ###\n    @property [Map<String, HoleNode>] holes A mapping of hole IDs to their nodes.\n    ###\n    Object.defineProperty this, 'holes',\n      get: () ->\n        @childList\n          .filter (elm) ->\n            elm.constructor.name is 'HoleNode'\n          .reduce ((acc, elm) ->\n            acc[elm.value.identifier] = elm\n            return acc), {}\n\n    ###\n    @property [Map<String, ExpressionNode>] expressions A mapping of expression\n      IDs to their nodes.\n    ###\n    Object.defineProperty this, 'expressions',\n      get: () ->\n        @childList\n          .filter (elm) ->\n            elm.constructor.name is 'ExpressionNode'\n          .reduce ((acc, elm) ->\n            acc[elm.key] = elm\n            return acc), {}\n\n    ###\n    @property [Map<String, InputNode>] inputs A mapping of input IDs to their\n      nodes.\n    ###\n    Object.defineProperty this, 'inputs',\n      get: () ->\n        @childList\n          .filter (elm) ->\n            elm.constructor.name is 'InputNode'\n          .reduce ((acc, elm) ->\n            acc[elm.value.identifier] = elm\n            return acc), {}\n\n    ###\n    @property [Array<LiteralNode>] literals An ordered list of this node's\n      template's literals.\n    ###\n    Object.defineProperty this, 'literals',\n      get: () ->\n        @childList.filter (elm) ->\n          elm.constructor.name is 'LiteralNode'\n\n    ###\n    @property [Subexpression] template A reference to the parent's template.\n    ###\n    Object.defineProperty this, 'template',\n      get: () -> @value.template\n\n    # Populate this node's children with the template's information.\n    holeCounter = 0\n    expressionCounter = 0\n    literalCounter = 0\n\n    @template\n      .forEach (piece) => switch piece.type\n      # TODO: wrap these in ExpressionNodes according to quantifiers\n        when 'hole'\n          # console.log 'adding hole'\n          @addChild \\\n            \".#{piece.identifier}\",\n            new HoleNode piece.identifier, piece.acceptCondition\n        when 'subexpression'\n          # console.log 'adding subexpr'\n          @addChild \\\n            \"@#{piece.identifier}\",\n            new ExpressionNode piece\n        when 'literal'\n          console.log 'adding literal; todo'\n          @addChild \"$#{literalCounter++}\", new LiteralNode piece.text\n        when 'input' # ?\n          console.log 'adding input; todo'\n          @addChild \\\n            \"|#{piece.identifier}\",\n            new InputNode input.identifier, input.pattern\n\n\n\n\n###\nA `HoleNode` represents a figurative \"hole\" in the source code which awaits\n  being \"filled\" by an expression.\nThe `value` field of this node holds a predicate to determine which expressions\n  are eligible to fill this hole.\n###\nclass HoleNode extends TreeModel\n  ###\n  @param [Function<Template, Boolean>] acceptCondition Returns `true`\n    if this hole can accept the specified template.\n  ###\n  constructor: (identifier, acceptCondition = (-> false)) ->\n    super\n      identifier: identifier\n      acceptCondition: acceptCondition\n\n    ###\n    @property [ExpressionNode] expression The `ExpressionNode` which is filling\n      this hole; if not filled, this is `null`.\n    ###\n    Object.defineProperty this, 'expression',\n      get: () -> @getChild 'expression'\n\n    ###\n    @property [Boolean] isFilled `true` if this hole is filled with an\n      expression, else `false.\n    ###\n    Object.defineProperty this, 'isFilled',\n      get: () -> (@getChild 'expression')?\n\n    ###\n    @property [Function<Template, Boolean>] acceptCondition Returns\n      `true` if this hole can accept the specified template.\n    ###\n    Object.defineProperty this, 'acceptCondition',\n      get: () -> @value.acceptCondition\n\n  ###\n  @param [Template] template The subexpression with which to fill this hole.\n  @return [ExpressionNode] The expression node created and used to fill this\n    hole, or `null` if unsuccessful fill.\n  ###\n  fill: (template) ->\n    if @acceptCondition template\n      @setChild \\\n        'expression',\n        new ExpressionNode template.expression\n    else null\n\n\n###\nTODO\n###\nclass LiteralNode extends TreeModel\n\n###\nTODO\n###\nclass InputNode extends TreeModel\n\n\n\nmodule.exports =\n  ExpressionNode: ExpressionNode\n  InstanceNode: InstanceNode\n  HoleNode: HoleNode\n  LiteralNode: LiteralNode\n  InputNode: InputNode","ST = require 'SyntaxTree'\n\n\nclass MockTemplate\n  constructor: (@expression, @group) ->\n\nclass MockPiece\n  constructor: (@type) ->\n\nclass MockHole extends MockPiece\n  constructor: (@identifier, @quantifier, @acceptCondition) ->\n    super 'hole'\n\nclass MockSubexpr extends MockPiece\n  constructor: (@identifier, @quantifier, @pieces) ->\n    super 'subexpression'\n\nclass MockLiteral extends MockPiece\n  constructor: (@quantifier, @text) ->\n    super 'literal'\n\nclass MockInput extends MockPiece\n  constructor: (@identifier, @quantifier, @pattern) ->\n    super 'input'\n\n\ndescribe 'Filling a syntax tree', () ->\n  beforeEach () ->\n    @root = new ST.HoleNode 'start', (expr) ->\n      expr.group == 'START'\n\n    @sb1 = new MockSubexpr 'subexpr1', 'one', [\n      new MockLiteral 'one', '[ '\n      new MockHole 'center', 'one', (exp) ->\n        exp.group is 'groupA'\n      new MockLiteral 'one', ' ]'\n    ]\n\n    @sb2 = new MockSubexpr 'subexpr2', 'one', [\n      new MockLiteral 'one', 'fi11er'\n    ]\n\n    @sb3 = new MockSubexpr 'subexpr3', 'one', [\n      new MockLiteral 'one', 'fi22er'\n    ]\n\n    @sb4 = new MockSubexpr 'subexpr4', 'one', [\n      new MockLiteral 'one', 'fiBBer'\n    ]\n\n  it 'works on a basic level', () ->\n    @root.fill (new MockTemplate @sb1, 'START')\n\n    expect @root.isFilled\n      .toBe true\n    expect @root.expression.template\n      .toBe @sb1.pieces\n\n\n    expect @root.expression.instances\n      .toBeDefined()\n    expect @root.expression.instances.length\n      .toBe 0\n\n    @root.expression.instantiate()\n\n    expect @root.expression.instances.length\n      .toBe 1\n    expect @root.expression.instances[0].template\n      .toBe @root.expression.template\n    expect @root.expression.instances[0].childList.length\n      .toBe 3\n    expect @root.expression.instances[0].literals.length\n      .toBe 2\n    expect Object.keys(@root.expression.instances[0].holes).length\n      .toBe 1\n    expect Object.keys(@root.expression.instances[0].inputs).length\n      .toBe 0\n    expect Object.keys(@root.expression.instances[0].expressions).length\n      .toBe 0\n\n    sb2_ = @root.expression.instances[0].holes['center'].fill (new MockTemplate @sb2, 'groupA')\n    expect sb2_\n      .not.toBeNull()\n    expect sb2_.template\n      .toBe @sb2.pieces\n\n\n  it 'can reject bad fills', () ->\n    result = @root.fill (new MockTemplate @sb1, 'STOAT')\n\n    expect result\n      .toBeNull()\n    expect @root.isFilled\n      .toBe false\n\n    result = @root.fill (new MockTemplate @sb1, 'START')\n    expect result\n      .not.toBeNull()\n    expect @root.isFilled\n      .toBe true\n\n    @root.expression.instantiate()\n    centerHole =\n      @root\n        .expression\n        .instances[0]\n        .holes['center']\n    result2 = centerHole.fill (new MockTemplate 'invalidGroup', @sb2)\n\n    expect result2\n      .toBeNull()\n    expect centerHole.isFilled\n      .toBe false","# require 'spec/SyntaxSpec'\n# require 'spec/ModeManagerSpec'\nrequire 'spec/SyntaxTreeSpec'"]}