(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var EventTargetMixin, TreeModel, extend,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  EventTargetMixin = require('oo-eventtarget');

  extend = function(obj, fields) {
    var key, result, value;
    result = {};
    for (key in obj) {
      value = obj[key];
      result[key] = value;
    }
    for (key in fields) {
      value = fields[key];
      result[key] = value;
    }
    return result;
  };


  /*
  Represents nested data as an ordered tree structure. Provides support for
  mutation observation. Can be used in conjunction with `TreeTransformer` to
  lazily and automatically transform between different tree representations.
   */

  TreeModel = (function() {

    /*
    Constructs a `TreeModel` with an optional value to hold.
    
    @param [a] value This node's held value.
     */
    function TreeModel(value1) {
      this.value = value1;
      this._bubble = bind(this._bubble, this);
      this._mutate((function(_this) {
        return function() {
          EventTargetMixin(_this);

          /*
          @property [Array] Mapping of keys to this node's children, in the form:
            node: TreeModel
            key: String
           */
          _this._children = {};

          /*
          @property [Array<String>] An ordered list of keys for this node's children.
           */
          _this.orderedChildrenKeys = [];

          /*
          @property [Array<TreeModel>] An ordered list of this node's children.
           */
          return Object.defineProperty(_this, 'childList', {
            get: function() {
              return this.orderedChildrenKeys.map((function(_this) {
                return function(key) {
                  return _this._children[key].node;
                };
              })(this));
            }
          });
        };
      })(this));
    }


    /*
    @property [TreeModel] This node's parent node, or `null` if root.
     */

    TreeModel.prototype.parent = null;


    /*
    @property [String] The key by which this node's parent refers to this node,
      or `null` if root.
     */

    TreeModel.prototype.key = null;


    /*
    @param [String] key
    @return [TreeModel] The specified child node, or `null` if no such child.
     */

    TreeModel.prototype.getChild = function(key) {
      if (this._children[key] != null) {
        return this._children[key].node;
      } else {
        return null;
      }
    };


    /*
    Returns the index of the specified child, or `null` if no such child.
    
    @param [String] key
    @return [Integer] The index of the child at `key`, or `null` if no such child.
     */

    TreeModel.prototype.getIndexOfChild = function(key) {
      if (this._children[key] != null) {
        return this._children[key].index;
      } else {
        return null;
      }
    };


    /*
    @param [String] key
    @param [TreeModel] node
     */

    TreeModel.prototype.addChild = function(key, node) {
      return this._mutate((function(_this) {
        return function() {
          var index;
          if (key == null) {
            return null;
          }
          _this.removeChild(key);
          node.parent = _this;
          node.key = key;
          node.addEventListener('changed', _this._bubble(key));
          _this.orderedChildrenKeys.push(key);
          index = _this.orderedChildrenKeys.length - 1;
          _this._children[key] = {
            node: node,
            index: index
          };
          return _this._children[key].node;
        };
      })(this));
    };


    /*
    If a child exists at the specified key, replaces the child node at `key` with
      the specified node.
      If no such child exists, adds the node as a child at the specified key.
    
    @param [String] key The child's key.
    @param [TreeModel] node The node to put in the existing child's place.
    @return [TreeModel] The "adopted" child node (`node`)
     */

    TreeModel.prototype.setChild = function(key, node) {
      if (this._children[key] != null) {
        return this._mutate((function(_this) {
          return function() {
            return _this._children[key].node = node;
          };
        })(this));
      } else {
        return this.addChild(key, node);
      }
    };


    /*
    @param [String] key Key of child to be removed.
    @return [TreeModel] The removed child.
     */

    TreeModel.prototype.removeChild = function(key) {
      var toDelete;
      if (this._children[key] != null) {
        toDelete = this._children[key];
        return this._mutate((function(_this) {
          return function() {
            return toDelete.node._mutate(function() {
              var reorderChildren;
              toDelete.node.removeEventListener('changed', _this._bubble(key));
              toDelete.node.parent = null;
              toDelete.node.key = null;
              _this.orderedChildrenKeys.splice(_this._children[key].index, 1);
              delete _this._children[key];
              reorderChildren = function(startIndex) {
                var i, j, ref, ref1, results;
                results = [];
                for (i = j = ref = startIndex, ref1 = _this.orderedChildrenKeys.length; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
                  results.push(_this._children[_this.orderedChildrenKeys[i]].index = i);
                }
                return results;
              };
              reorderChildren(toDelete.index);
              return toDelete.node;
            });
          };
        })(this));
      }
    };


    /*
    Alias for `removeChild`.
    
    @param [String] key Key of child to be detached.
    @return [TreeModel] The detached child.
     */

    TreeModel.prototype.detach = function() {
      return this.removeChild.apply(this, arguments);
    };


    /*
    Creates a new node and places it at the provided path.
    
    Note: This is a mutating method, but the mutation is delegated to the
    new node's parent via `addChild`.
    
    @param [Array<String>] path The path where the new node should live.
    @param [a] value The value to be placed in the new node.
    @return [TreeModel<a>] The newly-created node, or `null` if invalid path.
     */

    TreeModel.prototype.put = function(arg, value) {
      var j, key, parent, parentPath;
      parentPath = 2 <= arg.length ? slice.call(arg, 0, j = arg.length - 1) : (j = 0, []), key = arg[j++];
      parent = this.navigate(parentPath);
      if ((parent != null) && (key != null)) {
        return parent.addChild(key, new TreeModel(value));
      } else {
        if (key == null) {
          throw new RangeError('Attempted to put value at an undefined key.');
        } else if (parent == null) {
          throw new RangeError('Attempted to put value at invalid path.');
        }
      }
    };


    /*
    Navigates to a node and returns that node if it exists.
    
    @param [Array<String>] path A path to the node, with the node's key as the last element.
    @return [TreeModel] The specified node, or `null` if no such node.
     */

    TreeModel.prototype.navigate = function(path) {
      var hd, ref, tl;
      hd = path[0], tl = 2 <= path.length ? slice.call(path, 1) : [];
      switch (false) {
        case hd == null:
          return (ref = this.getChild(hd)) != null ? ref.navigate(tl) : void 0;
        default:
          return this;
      }
    };


    /*
    Removes all children from this node.
    
    @return [TreeModel] This model.
     */

    TreeModel.prototype.clear = function() {
      return this._mutate((function(_this) {
        return function() {
          _this.orderedChildrenKeys.forEach(function(key) {
            return _this.removeChild(key);
          });
          return _this;
        };
      })(this));
    };


    /*
     */

    TreeModel.prototype.batchMutate = function(proc) {
      return this._mutate((function(_this) {
        return function() {
          return proc(_this);
        };
      })(this));
    };


    /*
    Performs a mutation action, sending off changed events.
    
    @param [Function] procedure The action to perform.
    @return [?] The result of procedure.
     */

    TreeModel.prototype._mutate = function(procedure) {
      var r;
      if (!this._isMutating) {
        this._isMutating = true;
        r = procedure();
        this._fireChanged();
        this._isMutating = false;
        return r;
      } else {
        return procedure();
      }
    };


    /*
    Fires a changed event.
    
    @param [TreeModel] node The changed node.
     */

    TreeModel.prototype._fireChanged = function() {
      return this.dispatchEvent('changed', {
        node: this,
        path: []
      });
    };

    TreeModel.prototype._bubble = function(childKey) {
      return (function(_this) {
        return function(evt) {
          var data;
          if (!_this._isMutating) {
            data = extend(evt.data, {
              path: [childKey].concat(slice.call(evt.data.path))
            });
            return _this.dispatchEvent(evt.type, data);
          }
        };
      })(this);
    };

    return TreeModel;

  })();

  module.exports = TreeModel;

}).call(this);

},{"oo-eventtarget":2}],2:[function(require,module,exports){
module.exports = require("./lib/$EventTarget.js");
},{"./lib/$EventTarget.js":3}],3:[function(require,module,exports){
/**
	$EventTarget mixin
	@author Bart Van Beurden
	@date 26/01/2014
**/

/**
	Events dispatched by $EventTarget have 3 properties:
	- type (string)
	- target (event source)
	- data (user-provided)
**/
var Event = function(type, target, data) {
	this.type = type;
	this.target = target;
	this.data = data;
};

/**
	$EventTarget mixin
	Extends an object with EventTarget methods
	(adds #addEventListener, #removeEventListener, #dispatchEvent)
	@param obj The object to extend
**/
module.exports = function(obj) {

	obj._listeners = {};
	var proto = Object.getPrototypeOf(obj);
	
	// if necessary, extend prototype
	if (!proto.addEventListener) {
	
		/**
			$EventTarget#addEventListener
			@param type The event Type to listen to
			@param callback(event) The listener function
			@returns this
		**/
		Object.defineProperty(proto, "addEventListener", { value: function(type, callback) {
			console.assert(typeof type == "string", "$EventTarget#addEventListener - type must be string");
			console.assert(typeof callback == "function", "$EventTarget#addEventListener - callback must be function");
			
			var listeners = this._listeners[type];
			if (!listeners) listeners = this._listeners[type] = [];
			listeners.push(callback);
			return this;
		}});
		
		/**
			$EventTarget#removeEventListener
			@param type The event Type to remove
			@param callback(event) The listener function to remove
			@returns this
		**/
		Object.defineProperty(proto, "removeEventListener", { value: function(type, callback) {
			console.assert(typeof type == "string", "$EventTarget#removeEventListener - type must be string");
			console.assert(typeof callback == "function", "$EventTarget#removeEventListener - callback must be function");
			
			var listeners = this._listeners[type];
			if (listeners) {
				var index = listeners.indexOf(callback);
				if (index != -1) {
					listeners.splice(index, 1);
					if (listeners.length == 0) delete this._listeners[type];
				}
			}
			return this;
		}});
		
		Object.defineProperty(proto, "clearEventListeners", { value: function(type) {
			
			if (arguments.length == 0) {
				this._listeners = {};
			} else {
				delete this._listeners[type];
			}
			return this;
		}});
		
		var dispatcher = function(event) { 
			return function(callback) { 
				callback(event);
			};
		};
		
		/**
			$EventTarget#dispatchEvent
			@param type The type of the event to dispatch
			@param data [Optional] The data to pass to the listeners
		**/
		Object.defineProperty(proto, "dispatchEvent", { value: function(type, data) {
			console.assert(typeof type == "string", "$EventTarget#dispatchEvent - type must be string");
			
			(this._listeners[type] || []).forEach(dispatcher(new Event(type, this, data)));
		}});
	};
	
	return obj;

};
},{}],4:[function(require,module,exports){
var ExpressionNode, HoleNode, InputNode, InstanceNode, LiteralNode, TreeModel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

TreeModel = require('TreeModel');


/*
TREE STRUCTURE

HoleNode -> ExpressionNode

ExpressionNode -> Array<InstanceNode>

InstanceNode -> Array<ExpressionNode>
InstanceNode -> Array<HoleNode>
InstanceNode -> Array<InputNode>
InstanceNode -> Array<LiteralNode>

InputNode -> LiteralNode ? (to hold the user string)
 */


/*
Template ::=
  group: [String]
  expression: [Subexpression]

Piece ::= [Subexpression]
        | [Hole]
        | [Literal]
        | [Input]

Subexpression ::=
  type: 'subexpression'
  quantifier: [String]
  identifier: [String]
  pieces: [Array<Piece>]

Hole ::=
  type: 'hole'
  quantifier: [String]
  identifier: [String]
  acceptCondition: [Function<Template, Boolean>]

Literal ::=
  type: 'literal'
  quantifier: [String]
  text: [String]

Input ::=
  type: 'input'
  quantifier: [String]
  identifier: [String]
  pattern: [String]
 */


/*
An `ExpressionNode` represents a template of grammatical pieces. This template
  is instantiated one or more times into `InstanceNode`s.
  For an `ExpressionNode` to be represented in the output source, it must have at
  least one `InstanceNode`.

The `value` field of this node holds this expression's template.
 */

ExpressionNode = (function(superClass) {
  extend(ExpressionNode, superClass);


  /*
  Constructs an `ExpressionNode`, given the expression template.
  
  @param [Subexpression] expression The expression model.
   */

  function ExpressionNode(expression) {
    var instanceCounter;
    ExpressionNode.__super__.constructor.call(this, {
      identifier: expression.identifier,
      template: expression.pieces
    });

    /*
    @property [Array<InstanceNode>] instances An ordered list of this
      `ExpressionNode`'s `InstanceNode`s.
     */
    Object.defineProperty(this, 'instances', {
      get: function() {
        return this.childList;
      }
    });

    /*
    @property [Array<Piece>] template The template which all instances of this
      node should follow.
     */
    Object.defineProperty(this, 'template', {
      get: function() {
        return this.value.template;
      }
    });
    instanceCounter = 0;
    this._instanceIndex = function() {
      return instanceCounter++;
    };
  }


  /*
  Creates and adds an empty instance to the end of this node's list of
    instances.
  @return [InstanceNode] The newly created node.
   */

  ExpressionNode.prototype.instantiate = function() {
    var key;
    key = '#' + this._instanceIndex();
    return this.addChild(key, new InstanceNode(this.template));
  };

  return ExpressionNode;

})(TreeModel);


/*
An `InstanceNode` is an instantiation of an `ExpressionNode`, which offers a
  buffer in which to fill the `ExpressionNode`'s template.
The `value` field of this node holds a reference to the parent
  `ExpressionNode`'s template.
 */

InstanceNode = (function(superClass) {
  extend(InstanceNode, superClass);


  /*
  @param [Array<Piece>] template
   */

  function InstanceNode(template) {
    var expressionCounter, holeCounter, literalCounter;
    InstanceNode.__super__.constructor.call(this, {
      template: template

      /*
      @property [Map<String, HoleNode>] holes A mapping of hole IDs to their nodes.
       */
    });
    Object.defineProperty(this, 'holes', {
      get: function() {
        return this.childList.filter(function(elm) {
          return elm.constructor.name === 'HoleNode';
        }).reduce((function(acc, elm) {
          acc[elm.value.identifier] = elm;
          return acc;
        }), {});
      }
    });

    /*
    @property [Map<String, ExpressionNode>] expressions A mapping of expression
      IDs to their nodes.
     */
    Object.defineProperty(this, 'expressions', {
      get: function() {
        return this.childList.filter(function(elm) {
          return elm.constructor.name === 'ExpressionNode';
        }).reduce((function(acc, elm) {
          acc[elm.key] = elm;
          return acc;
        }), {});
      }
    });

    /*
    @property [Map<String, InputNode>] inputs A mapping of input IDs to their
      nodes.
     */
    Object.defineProperty(this, 'inputs', {
      get: function() {
        return this.childList.filter(function(elm) {
          return elm.constructor.name === 'InputNode';
        }).reduce((function(acc, elm) {
          acc[elm.value.identifier] = elm;
          return acc;
        }), {});
      }
    });

    /*
    @property [Array<LiteralNode>] literals An ordered list of this node's
      template's literals.
     */
    Object.defineProperty(this, 'literals', {
      get: function() {
        return this.childList.filter(function(elm) {
          return elm.constructor.name === 'LiteralNode';
        });
      }
    });

    /*
    @property [Subexpression] template A reference to the parent's template.
     */
    Object.defineProperty(this, 'template', {
      get: function() {
        return this.value.template;
      }
    });
    holeCounter = 0;
    expressionCounter = 0;
    literalCounter = 0;
    this.template.forEach((function(_this) {
      return function(piece) {
        switch (piece.type) {
          case 'hole':
            return _this.addChild("." + piece.identifier, new HoleNode(piece.identifier, piece.acceptCondition));
          case 'subexpression':
            return _this.addChild("@" + piece.identifier, new ExpressionNode(piece));
          case 'literal':
            console.log('adding literal; todo');
            return _this.addChild("$" + (literalCounter++), new LiteralNode(piece.text));
          case 'input':
            console.log('adding input; todo');
            return _this.addChild("|" + piece.identifier, new InputNode(input.identifier, input.pattern));
        }
      };
    })(this));
  }

  return InstanceNode;

})(TreeModel);


/*
A `HoleNode` represents a figurative "hole" in the source code which awaits
  being "filled" by an expression.
The `value` field of this node holds a predicate to determine which expressions
  are eligible to fill this hole.
 */

HoleNode = (function(superClass) {
  extend(HoleNode, superClass);


  /*
  @param [Function<Template, Boolean>] acceptCondition Returns `true`
    if this hole can accept the specified template.
   */

  function HoleNode(identifier, acceptCondition) {
    if (acceptCondition == null) {
      acceptCondition = (function() {
        return false;
      });
    }
    HoleNode.__super__.constructor.call(this, {
      identifier: identifier,
      acceptCondition: acceptCondition
    });

    /*
    @property [ExpressionNode] expression The `ExpressionNode` which is filling
      this hole; if not filled, this is `null`.
     */
    Object.defineProperty(this, 'expression', {
      get: function() {
        return this.getChild('expression');
      }
    });

    /*
    @property [Boolean] isFilled `true` if this hole is filled with an
      expression, else `false.
     */
    Object.defineProperty(this, 'isFilled', {
      get: function() {
        return (this.getChild('expression')) != null;
      }
    });

    /*
    @property [Function<Template, Boolean>] acceptCondition Returns
      `true` if this hole can accept the specified template.
     */
    Object.defineProperty(this, 'acceptCondition', {
      get: function() {
        return this.value.acceptCondition;
      }
    });
  }


  /*
  @param [Template] template The subexpression with which to fill this hole.
  @return [ExpressionNode] The expression node created and used to fill this
    hole, or `null` if unsuccessful fill.
   */

  HoleNode.prototype.fill = function(template) {
    if (this.acceptCondition(template)) {
      return this.setChild('expression', new ExpressionNode(template.expression));
    } else {
      return null;
    }
  };

  return HoleNode;

})(TreeModel);


/*
TODO
 */

LiteralNode = (function(superClass) {
  extend(LiteralNode, superClass);

  function LiteralNode() {
    return LiteralNode.__super__.constructor.apply(this, arguments);
  }

  return LiteralNode;

})(TreeModel);


/*
TODO
 */

InputNode = (function(superClass) {
  extend(InputNode, superClass);

  function InputNode() {
    return InputNode.__super__.constructor.apply(this, arguments);
  }

  return InputNode;

})(TreeModel);

module.exports = {
  ExpressionNode: ExpressionNode,
  InstanceNode: InstanceNode,
  HoleNode: HoleNode,
  LiteralNode: LiteralNode,
  InputNode: InputNode
};


},{"TreeModel":1}],5:[function(require,module,exports){
var MockHole, MockInput, MockLiteral, MockPiece, MockSubexpr, MockTemplate, ST,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ST = require('SyntaxTree');

MockTemplate = (function() {
  function MockTemplate(expression, group) {
    this.expression = expression;
    this.group = group;
  }

  return MockTemplate;

})();

MockPiece = (function() {
  function MockPiece(type) {
    this.type = type;
  }

  return MockPiece;

})();

MockHole = (function(superClass) {
  extend(MockHole, superClass);

  function MockHole(identifier, quantifier, acceptCondition) {
    this.identifier = identifier;
    this.quantifier = quantifier;
    this.acceptCondition = acceptCondition;
    MockHole.__super__.constructor.call(this, 'hole');
  }

  return MockHole;

})(MockPiece);

MockSubexpr = (function(superClass) {
  extend(MockSubexpr, superClass);

  function MockSubexpr(identifier, quantifier, pieces) {
    this.identifier = identifier;
    this.quantifier = quantifier;
    this.pieces = pieces;
    MockSubexpr.__super__.constructor.call(this, 'subexpression');
  }

  return MockSubexpr;

})(MockPiece);

MockLiteral = (function(superClass) {
  extend(MockLiteral, superClass);

  function MockLiteral(quantifier, text) {
    this.quantifier = quantifier;
    this.text = text;
    MockLiteral.__super__.constructor.call(this, 'literal');
  }

  return MockLiteral;

})(MockPiece);

MockInput = (function(superClass) {
  extend(MockInput, superClass);

  function MockInput(identifier, quantifier, pattern) {
    this.identifier = identifier;
    this.quantifier = quantifier;
    this.pattern = pattern;
    MockInput.__super__.constructor.call(this, 'input');
  }

  return MockInput;

})(MockPiece);

describe('Filling a syntax tree', function() {
  beforeEach(function() {
    this.root = new ST.HoleNode('start', function(expr) {
      return expr.group === 'START';
    });
    this.sb1 = new MockSubexpr('subexpr1', 'one', [
      new MockLiteral('one', '[ '), new MockHole('center', 'one', function(exp) {
        return exp.group === 'groupA';
      }), new MockLiteral('one', ' ]')
    ]);
    this.sb2 = new MockSubexpr('subexpr2', 'one', [new MockLiteral('one', 'fi11er')]);
    this.sb3 = new MockSubexpr('subexpr3', 'one', [new MockLiteral('one', 'fi22er')]);
    return this.sb4 = new MockSubexpr('subexpr4', 'one', [new MockLiteral('one', 'fiBBer')]);
  });
  it('works on a basic level', function() {
    var sb2_;
    this.root.fill(new MockTemplate(this.sb1, 'START'));
    expect(this.root.isFilled).toBe(true);
    expect(this.root.expression.template).toBe(this.sb1.pieces);
    expect(this.root.expression.instances).toBeDefined();
    expect(this.root.expression.instances.length).toBe(0);
    this.root.expression.instantiate();
    expect(this.root.expression.instances.length).toBe(1);
    expect(this.root.expression.instances[0].template).toBe(this.root.expression.template);
    expect(this.root.expression.instances[0].childList.length).toBe(3);
    expect(this.root.expression.instances[0].literals.length).toBe(2);
    expect(Object.keys(this.root.expression.instances[0].holes).length).toBe(1);
    expect(Object.keys(this.root.expression.instances[0].inputs).length).toBe(0);
    expect(Object.keys(this.root.expression.instances[0].expressions).length).toBe(0);
    sb2_ = this.root.expression.instances[0].holes['center'].fill(new MockTemplate(this.sb2, 'groupA'));
    expect(sb2_).not.toBeNull();
    return expect(sb2_.template).toBe(this.sb2.pieces);
  });
  return it('can reject bad fills', function() {
    var centerHole, result, result2;
    result = this.root.fill(new MockTemplate(this.sb1, 'STOAT'));
    expect(result).toBeNull();
    expect(this.root.isFilled).toBe(false);
    result = this.root.fill(new MockTemplate(this.sb1, 'START'));
    expect(result).not.toBeNull();
    expect(this.root.isFilled).toBe(true);
    this.root.expression.instantiate();
    centerHole = this.root.expression.instances[0].holes['center'];
    result2 = centerHole.fill(new MockTemplate('invalidGroup', this.sb2));
    expect(result2).toBeNull();
    return expect(centerHole.isFilled).toBe(false);
  });
});


},{"SyntaxTree":4}],6:[function(require,module,exports){
require('spec/SyntaxTreeSpec');


},{"spec/SyntaxTreeSpec":5}]},{},[6])


//# sourceMappingURL=test-bundle.js.map